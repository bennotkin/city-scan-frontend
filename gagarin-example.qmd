---
title: "Gagarin City Scan Test"
format:
  html:
    theme: [custom.scss, none]
slide-level: 3
editor: visual
execute:
  echo: false
---

```{ojs}
//| output: false

// Move this to a separate file so it's out of the way

// import and instantiate the scrollama
// not sure if install is required, but here is how:
// `$ npm install scrollama intersection-observer --save`
scrollama = require("scrollama@3.1.1");
scroller = scrollama();
d3 = require("d3");

// Define variables (taken from template, might not need all of them)
$container = d3.select("main.content");
$graphic = $container.select(".maps");
// $chart = $graphic.select("#scrollama-test")
$text = $container.select(".text-column");
$step = $text.selectAll("section.level3");
$layerControl = $graphic.select(".leaflet-control-layers-list");
$overlaysControl = $layerControl.select(".leaflet-control-layers-overlays");

overlayLayers = Array.prototype.map
  .call($overlaysControl.node().getElementsByTagName("span"), span => {
    return(span.textContent.replace(/\s/g, ""))
  }) // Need to replace white space with nothing because .textContent returns a leading space

// console.log(overlayLayers)

function checkLayerStatus(spanText) {
  var inputs = $overlaysControl.node().getElementsByTagName("input")
  var index = overlayLayers.indexOf(spanText)
  return(inputs[index].checked)
}

function handleStepEnter(response) {
  // response = { element, direction, index }

  console.log("Enter triggered")
  console.log(response)

  // console.log(layers)
  // console.log($overlaysControl.html())
  // console.log(response.element.id)

  $step.classed("is-active", function (d, i) {
    return i === response.index;
  })
  
  $graphic.classed("is-active", function (d, i) {
    var colorRows = [1, 3]
    return colorRows.includes(response.index)
  })
  
    // This is for testing purposes and requires a level 3 header and a paragraph above the map
  // var header = $graphic.select("h3")
  // var mapText = $graphic.select("p")
  // header.text(response.element.id)
  
  var layerIndex = overlayLayers.indexOf(response.element.id)
  if (layerIndex >= 0) {
    // This is for testing purposes and requires a level 3 header and a paragraph above the map
    // mapText.text(response.element.id);
    console.log(response.element.id + ": " + checkLayerStatus(response.element.id));
    if (!checkLayerStatus(response.element.id)) {
      $overlaysControl.node().getElementsByTagName("input")[layerIndex].click()
    }
  }
}

function handleStepExit(response) {
  console.log("Exit triggered")
  console.log(response)
  // { element, index, direction }
  response.element.classList.remove("is-active");
  
  var layerIndex = overlayLayers.indexOf(response.element.id)
  if (layerIndex >= 0) {
    console.log(response.element.id + ": " + checkLayerStatus(response.element.id));
    if (checkLayerStatus(response.element.id)) {
      $overlaysControl.node().getElementsByTagName("input")[layerIndex].click()
    }
  }
}
// initialise the library and pass event handlers to 
function init() {
  scroller
    .setup({
			container: 'main.content', // our outermost scrollytelling element
			graphic: '.maps', // the graphic
			text: '.text-column', // the step container
			step: '.text-column section.level3', // the step elements
			offset: 0.5, // set the trigger to be 1/2 way down screen
			debug: false, // display the trigger offset for testing
    })
    .onStepEnter(handleStepEnter)
    .onStepExit(handleStepExit)
}

init();
```

::: setup
```{r}
#| include: false
# Read functions & packages
# Only the github version of leaflet supports terra, in place of raster, which is now required as sp (on which raster depends) is being deprecated
# devtools::install_github('rstudio/leaflet')
source("fns.R")

# City parameters
city_params <- read_yaml("city_inputs.yml")
# cities <- list.files("cities")
city <- city_params$city_name
city_string <- tolower(city) %>% stringr::str_replace_all(" ", "-")
city_dir <- paste0("cities/", city_string, "/")
output_dir <- paste0(city_dir, "styled-maps/")
# raster_dir <- paste0(city_dir, "/output")
country <- city_params$country

# Visualization parameters
basemap_opacity <- 0.3
legend_opacity <- 0.8
vwidth <- 900
vheight <- vwidth

# this is to enable fractional zoom in mapshot
useragent <- 'Mozilla/5.0 (compatible; MSIE 10.6; Windows NT 6.1; Trident/5.0; InfoPath.2; SLCC1; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 2.0.50727) 3gpp-gba UNTRUSTED/1.0'

# Layers
layer_params <- read_yaml('layers.yml')
```

```{r}
#| include: false

# Define the AOI
aoi <- st_read(paste0(city_dir, "AOI"))
aoi_bounds <- st_bbox(aoi)

# Inititate the map here, will build on it in each "slide"
all_maps <- plot_basemap("vector")

# Keep track of added layers
added_layers <- c()
```
:::

::: navigation
```{r}
#| output: asis
# Dynamically add sections to table of contents ... there's probably a better way?
sections <- readLines("/Users/bennotkin/Documents/world-bank/crp/city-scans/city-scan-automation/frontend/city-scan-html-sample/gagarin-example.qmd") %>%
  subset(str_detect(., "^##")) %>% str_replace("# ", "- ") %>% str_replace_all("#", "  ")

anchors <- sections %>% str_extract("^\\s*- (.*$)", group = T) %>% tolower() %>% str_replace_all(c("[^a-z\\s]" = "", "\\s+" = "-")) %>%
  str_replace("(.*)", "(#\\1)")

paste0(str_replace(sections, "(^\\s*- )(.+$)", "\\1[\\2]"), anchors) %>% { cat("- T.O.C.", ., sep = "\n") }
```
:::

::: text-column
## Population and Demographic Trends

### Population Growth

<!-- ![](images/oxford-pop-growth.png) -->

-   From 2001 to 2011, the area's population grew from 10,060 to 10,391, at an average annual rate of just 0.3%
-   The villages Varser, Ddmashen and Zovaber grew in this period, while the villages Gagarin, Geghamavan, Tsaghkunk shrunk

Population figures are typically used as a denominator for many indicators, and are a measure of demand for services. The line chart above summarizes the city's population change according to census and other public data. High growth of urban populations, caused by rates of natural increase (more births than deaths) in urban areas, migration from rural to urban areas, and the transformation of rural settlements into urban places, puts pressure on cities to meet the new demand.

### Population Charts

<!-- ![](images/oxford-pop-density-scatter.png) -->

-   Of the six villages, Gagarin has the highest at 2,860 people per km<sup>2</sup>, while Tsaghkunk has the lowest at 1,057
-   Together, the six villages have a density of 1,689 people per km<sup>2</sup>, which is denser than Areni and Yerevan (1,174 per km<sup>2</sup>) but less dense than Dilijan and Gyumri

Density is calculated using the most recent census population recorded and the official land area occupied by the city, and is an important measure of how cities function. Higher population density enables governments to more easily deliver essential infrastructure and services in urban areas at relatively low cost per capita. However, such benefits do not materialize automatically or inevitably. Whether a city's population dynamics pose challenges or offer opportunities typically depends on the policies in play.

::: footnote
Populations and areas are from CityPopulation.de. Note that the extents used by CityPopulation.de may differ from the AOIs used by the City Scans. The area for Gagarin (Combined) uses the combined areas of each of the six included villages; it does not include the space in between.
:::

### Population Distribution by Age & Sex

<!-- ![](images/world-pop-age-sex.png) -->

-   The largest age group in the area is people ages 25--34
-   For males, another large age group is ages 0--14
-   90% of the population is younger than 60
-   68% of the population is of working age (15--64)
-   7% of the population is under 5 and 13% is youth (15--24)
-   Men and women are evenly represented: there are 101 men to every - 100 women
-   51% of all women in Gagarin are of reproductive age

This column chart classifies the city's population according to age group, forming the basis of population projections. Populations vary significantly in their proportions of young and old people, with growing populations generally appearing younger, and declining or slowly growing populations generally appearing older.

::: footnote
Data from WorldPop. Bondarenko, et al, Estimates of total number of people per grid square broken down by gender and age groupings for 51 countries across sub-Saharan Africa in 2020 using Ecopia.AI and Maxar Technologies building footprints, 2020.

Reproductive age is defined as 15--49. Working age is defined as 15--64.
:::

### Population Density

```{r}
#| include: false
# Read population data
pop <- fuzzy_read(city_dir, "population")
add_pop_layer <- create_layer_function(data = pop, yaml_key = "population")

all_maps <- add_pop_layer(all_maps)
  # This could be put into the add_*_layer() functions themselves
  # hideGroup("population-density")
added_layers <- c(added_layers, "population-density")
```

-   Population density is greatest in the western towns of Gagarin
-   It is lowest ...

This map estimates population numbers per 10,000 m<sup>2</sup> grid cell. It provides a more consistent representation of population distributions across different landscapes than administrative unit counts. Knowing where people are is critical for impact assessments and intervention plans, especially those focused on service delivery, food security, climate change, network systems and natural disasters.

::: footnote
Map data from WorldPop. Bondarenko, et al, Census/projection-disaggregated gridded population datasets, 2020.
:::

### Third level heading (###) creates new slide

A new slide will require new methodology text. Add this here in the second column. Columns can be added in RStudio using the Insert menu, or via markdown in any text editor.

::: footnote
Add any footnotes to this separate div with class `.footnote`.
:::

### Relative Wealth Index

```{r}
#| include: false
# Read RWI
rwi <-
  st_read(paste0(city_dir, "output/relative_wealth_index"), quiet = T) %>%
  select(values = rwi, long = longitude, lat = latitude)

# # Using terra intead of sf for consistency
# # Except this doesn't work well because there are multiple value columns so it gets complicated to use programmatically 
# rwi <- vect(paste0(city_dir, "output/relative_wealth_index"))

# rwi_range <- max(c(abs(min(rwi$values)), max(rwi$values))) %>% {c(-., 0, .)}

# rwi_color_scale <- colorNumeric(
#   palette = colorRamp(
#     c('#ED431B', '#FF9169', '#FFFFBA', '#70C5AD', '#009E7A'),
#     interpolate = 'linear'),
#   domain = NULL,
#   na.color = 'transparent')
# 
# add_rwi_layer <- function(map) {
#   map %>% addPolygons(
#     data = rwi,
#     fillColor = ~ rwi_color_scale(values),
#     fillOpacity = 1,
#     stroke = F,
#     group = "rwi",
#     label = ~ values) %>%
#     addLegend(
#       'bottomright',
#       pal = rwi_color_scale,
#       values = c(min(rwi$values, na.rm = T), max(rwi$values, na.rm = T)),
#       opacity = legend_opacity,
#       # bins = 3,  # legend color ramp does not render if there are too many bins
#       title = layer_params$rwi$title,
#       labFormat = labelFormat(),
#       group = "rwi",
#       # Adding classname because hideGroup() doesn't hide legend; see workaround
#       # here: https://github.com/rstudio/leaflet/issues/477#issuecomment-678542769
#       className = "info legend rwi"
#       )
# }
# 
# plot_basemap() %>% add_rwi_layer() %>%
#    htmlwidgets::onRender("
#       function(el, x) {
#          var updateLegend = function () {
#             var selectedGroup = document.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);
# 
#             document.querySelectorAll('.legend').forEach(a => a.hidden=true);
#             document.querySelectorAll('.legend').forEach(l => {
#                if (l.classList.contains(selectedGroup)) l.hidden=false;
#             });
#          };
#          updateLegend();
#          this.on('overlayremove', el => updateLegend());
#       }") %>%
#   hideGroup("rwi")

add_rwi_layer <- create_layer_function(data = rwi, yaml_key = "rwi")

all_maps <- add_rwi_layer(all_maps)
  # This could be put into the add_*_layer() functions themselves
  # hideGroup("relative-wealth-index")
added_layers <- c(added_layers, "relative-wealth-index")
```

-   Wealth appears greatest in the villages of Gagarin and, secondarily, Ddmashen
-   The lowest wealth areas are primarily areas with very low population density

This map shows micro-estimates of wealth and poverty relative to the whole country that cover the populated surface at a 2.4 km^2^ resolution. Many critical policy decisions, from strategic investments to the allocation of humanitarian aid, rely on data about the geographic distribution of wealth and poverty.

::: footnote
Map data from Meta Data for Good.
:::

### Now with layers control

Add text

::: footnote
See https://rstudio.github.io/leaflet/showhide.html
:::

## Another section

### And a "slide" within it

Text
:::

::: maps
```{r}
all_maps %>%
  add_aoi() %>%
  addLayersControl(
    overlayGroups = added_layers,
    options = layersControlOptions(collapsed = FALSE))

  # If I want to use javascript directly I could use htmlwidgets::onRender(),
  # or maybe just an observable cell
```
:::
